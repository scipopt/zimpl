#pragma ident "@(#) $Id: xlpglue.c,v 1.10 2003/09/01 08:27:28 bzfkocht Exp $"
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*   File....: numb2lp.c                                                     */
/*   Name....: Term Functions                                                */
/*   Author..: Thorsten Koch                                                 */
/*   Copyright by Author, All rights reserved                                */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*
 * Copyright (C) 2001 by Thorsten Koch <koch@zib.de>
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <gmp.h>

#include "bool.h"
#include "mshell.h"
#include "ratlp.h"
#include "mme.h"
#include "gmpmisc.h"
#include "xlpglue.h"

static Lps*        lp    = NULL;
static const char* title = "This file was automatically generated by Zimpl";
   

void xlp_alloc(const char* name)
{
   lp = lps_alloc(name);
}

void xlp_scale()
{
   lps_scale(lp);
}

void xlp_write(FILE* fp, LpFormat format)
{
   lps_write(lp, fp, format, title);
}

void xlp_transtable(FILE* fp, LpFormat format)
{
   lps_transtable(lp, fp, format == LP_FORM_LPF ? LPF_NAME_LEN : MPS_NAME_LEN, "zimpl");
}

void xlp_orderfile(FILE* fp, LpFormat format)
{
   lps_orderfile(lp, fp, format == LP_FORM_LPF ? LPF_NAME_LEN : MPS_NAME_LEN, title);
}

void xlp_free()
{
   lps_free(lp);
   lp = NULL;
}

Bool xlp_conname_exists(const char* conname)
{
   return NULL != lps_getcon(lp, conname);
}

Con* xlp_addcon(
   const char*  name,
   ConType      contype,
   const Numb*  lhs,
   const Numb*  rhs,
   unsigned int flags)
{
   Con*  con;
   mpq_t tlhs;
   mpq_t trhs;
   
   assert(name != NULL);
   assert(rhs  != NULL);
   
   con = lps_addcon(lp, name);

   assert(con != NULL);

   mpq_init(tlhs);
   mpq_init(trhs);
   
   numb_get_mpq(rhs, trhs);
   numb_get_mpq(lhs, tlhs);
   
   switch(contype)
   {
   case CON_RHS :
      lps_setrhs(con, trhs);
      break;
   case CON_LHS :
      lps_setlhs(con, tlhs);
      break;
   case CON_EQUAL : /* In case of EQUAL, both should be equal */
      assert(mpq_equal(tlhs, trhs));
      /*FALLTHROUGH*/
   case CON_RANGE :
      lps_setlhs(con, tlhs);
      lps_setrhs(con, trhs);
      break;
   default :
      abort();
   }
   lps_addflags(con, flags);

   mpq_clear(trhs);
   mpq_clear(tlhs);
   
   return con;
}

Var* xlp_addvar(
   const char*  name,
   VarClass     varclass,
   const Bound* lower,
   const Bound* upper,
   const Numb*  priority,
   const Numb*  startval)
{
   Var*      var;
   mpq_t     temp;
   
   assert(name  != NULL);
   assert(lower != NULL);
   assert(upper != NULL);

   var = lps_addvar(lp, name);

   lps_setclass(var, varclass);
   
   mpq_init(temp);

   if (bound_get_type(lower) == BOUND_VALUE)
   {
      numb_get_mpq(bound_get_value(lower), temp);
      lps_setlower(var, temp);
   }
   if (bound_get_type(upper) == BOUND_VALUE)
   {
      numb_get_mpq(bound_get_value(upper), temp);
      lps_setupper(var, temp);
   }
   numb_get_mpq(startval, temp);
   
   lps_setstartval(var, temp);

   numb_get_mpq(priority, temp);
   
   /*lint -e{663} supress "Suspicious array to pointer conversion" */
   if (mpz_get_si(mpq_denref(temp)) != 1)
      fprintf(stderr, "*** Warning variable priority has to be integral\n");

   /*lint -e{663} supress "Suspicious array to pointer conversion" */
   lps_setpriority(var, (int)mpz_get_si(mpq_numref(temp)));

   mpq_clear(temp);
   
   return var;
}

void xlp_objname(const char* name)
{
   lps_setobjname(lp, name);
}

void xlp_setdir(Bool minimize)
{
   lps_setdir(lp, minimize ? LP_MIN : LP_MAX);
}

void xlp_addtonzo(Var* var, Con* con, const Numb* value)
{
   Nzo*  nzo;
   mpq_t val1;

   assert(var   != NULL);
   assert(con   != NULL);
   assert(value != NULL);
   
   mpq_init(val1);
   numb_get_mpq(value, val1);
   
   nzo = lps_getnzo(lp, con, var);

   if (nzo == NULL)
      lps_addnzo(lp, con, var, val1);
   else
   {
      mpq_t val2;

      mpq_init(val2);

      lps_getval(nzo, val2);
      
      mpq_add(val1, val1, val2);

      if (mpq_equal(val1, const_zero))
         lps_delnzo(lp, nzo);
      else
         lps_setval(nzo, val1);

      mpq_clear(val2);
   }
   mpq_clear(val1);
}

void xlp_addtocost(Var* var, const Numb* cost)
{
   mpq_t val1;
   mpq_t val2;

   mpq_init(val1);
   mpq_init(val2);

   lps_getcost(var, val1);
   numb_get_mpq(cost, val2);
   mpq_add(val1, val1, val2);
   lps_setcost(var, val1);

   mpq_clear(val1);
   mpq_clear(val2);
}

void xlp_presolve()
{
   PSResult res;
   
   res = lps_presolve(lp, verbose ? 3 : 0);

   switch(res)
   {
   case PRESOLVE_INFEASIBLE :
      printf("Model is infeasible\n");
      exit(EXIT_SUCCESS);
   case PRESOLVE_UNBOUNDED :
      printf("Model is unbounded\n");
      exit(EXIT_SUCCESS);
   case PRESOLVE_VANISHED :
      printf("Presolve solved the problem -- see .tbl file for values\n");
      break;
   case PRESOLVE_OKAY :
      break;
   default :
      abort();
   }
}

     
