Tests für { <a> in A } 
Tests für ranges
Tests für preprocessing

Da jetzt   { <a> in A with a > 5 } geht, 
funktionen mit idxset die eigendlich sein sexpr 
brauchen wieder umstellen.

ranges: MPS write fehlt noch

zugrif auf set elemente nach ordnungsnummer, so das
for <i> in { 1 .. card(A) } do
   A[ord(i)] 
geht.


check:  errors.zpl felft, einer fuer jeden error/warnin
        außerdem errors warning durchnummeriern.
        dann err007.zpl

check:  var.zpl fehlt

Speedups:

numbgmp: mpq_clear aufrufen für verwendete oder schon erledigt.
strstore: string table, jeder nur einmal und dann handle. Macht auch
          str_has und str_cmp schneller.
auf explicite copys umstellen. Statt

numb = new_numb
elem = new_elem(numb);
tuple_new_tuple(elem);
free(elem);
free(numb);

nur noch 
tuple_new_tuple(new_elem(new_numb)));

und ansnsten hatlr

tuple_new_tuple(elem_copy(elem))));








Mindestens in Elem und Numb machen die SID wenig sinn,
weil sie nie zurueckgesetzt werden.

Einleseroutinen für indizerte Sets
Einleseroutinen für Matrizen:
    <1> <2> <3>
<5>  2   3   4
<6>  3   4   5
=> <5,1> 2, <5,2> 3 ...

tru64/opt INFINITY warnung
hp complett
valgrind opt/expr meldung
ibm ggf -qwarn64

VAR setktion in check

es fehlt noch sowas wie sum of sets (Big Uninion)

macht es sinn  "idxset : sexpr condition" zu haben ?
condition kann in keiner weise auf das element zugreifen.

macht es einen Sinn param x[<i> in I ...] := 3 * i mit default zu haben.
Es sind doch alle indices initialisiert.

indexset sollte auch für variablen und parametergehen.
-----------------------
Sollte man auf 0 fixierte Variablen entfernen ?
------------------------
idxset und sexpr vereinheitlichen, eigendlich ist ein
idxset immer eine sexpr

Mal überlegen ob es nicht eine ide wäre 
Metakontruckte eiinzuführen wie

IF x[i] > y[i] AND z[i] == 0 THEN
   x[i] + y[i] == 5
ELSE
   x[i] + y[i] + z[i] == 7
Was im prinzip ein bedingtes ODER ist.

   x[i] + y[i] == 5 OR x[i] + y[i] + z[i] == 7

------------------------------------------

lint: check bei passes(2+)

Warnung bei set operationen auf sets mit inkompatiblen tupeln
z.B. { 1, 2, 3 } \ { "3" }

-------------------------------

Demangle script. das die .lp + .tbl für menschen lesbar macht.

----------------------------
Potenzmengen und mengen element kann dann auch eine menge sein,
so das man sagen kann:

forall w in pot(V) with s in W do

---------------------------------------------------
exists <a,b,c> in X : b == 4 and c == 3  shift/reduce beseitigen count?

Teilmengen zuweisung in sexpr

min <a,b> in X : expr 
max =====================> Dokumentation

include gucken auch innerhalt eines ; ausdrucks.

ewtl bei lp_format etwas längere Dateinamen


shortcummings and Tips&Trick Abschnitt

check statement mit forall als reductionsoperator expr* -> bool

Im LP reihenfolge der sets beibehalten

bessere fehlermeldungen

Warning wenn locale Variable eine globale uerbschreibt.







