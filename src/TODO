check füer read/include siehe example

wenn -m gesetzt wird keine .tbl/.ord schreiben.

option fuer gerneiruung von kurzen variablenamen (nur x#262626)
überprüfen ob man mit unterschiedlichen strings gleiche namen bekommen kann.

set check erweitern fuer mengenoperationen inbesondere auch
boolsche mit der leeren menge. s.u.

Tests für boolsche operatoren. z.B. not wird nirgends getestet.

Funktion statistik Anzahl vars/Cons/Boxed/Fixed/NZOs etc, 
         (bei soplex/extr gibts schon so was)

Funktion timing.

define fun(name_list) := expr | term? | constraint?
              ^
              | Kein Problem, weil keine lokalen Variablen definiert sind.

Neuer Symboltyp SYM_FUN
return is klar aus dem was hinter ist.
Aufruf: fun(expr_list)
local_setup_match_name_list(name_list, expr_list)
eval.
u.u. müßte expr_list keine sein, sonder irgendwas, das sich als local auflösen läßt.
Fehlerausgabe Trace?
Recursion geht einfach so.


Test mit 1 Mill var einbauen oder Sascha fragen
ewtl :    x1 + x2, x2 + x3, ... x98 + x99, x99 = 5 => preprocessing

if (....) constraint else constraint endif 
und/oder
if (....) term else term endif 
einbauen

print set/param[] einbauen.

Bug mit datei ohne ; keine Ausgabe.
Falscher Dateityp sollte früher erkannt werden.

parameter mit -s auf der Kommandozeile setzen können.

check mit fixierten variablen.

check separate flag

checks auf für MPS

check: Tests für preprocessing

ranges: MPS write fehlt noch

zugriff auf set elemente nach ordnungsnummer, so das
for <i> in { 1 .. card(A) } do
   A[ord(i)] 
geht.


check:  errors.zpl felft, einer fuer jeden error/warnin
        außerdem errors warning durchnummeriern.
        dann err007.zpl

Speedups:

numbgmp: mpq_clear aufrufen für verwendete oder schon erledigt.
strstore: string table, jeder nur einmal und dann handle. Macht auch
          str_has und str_cmp schneller.


auf explicite copys umstellen. list elem entry

numb = new_numb
elem = new_elem(numb);
tuple_new_tuple(elem);
free(elem);
free(numb);

nur noch 
tuple_new_tuple(new_elem(new_numb)));

und ansnsten hatlr

tuple_new_tuple(elem_copy(elem))));








Mindestens in Elem und Numb machen die SID wenig sinn,
weil sie nie zurueckgesetzt werden.

Einleseroutinen für indizerte Sets
Einleseroutinen für Matrizen:
    <1> <2> <3>
<5>  2   3   4
<6>  3   4   5
=> <5,1> 2, <5,2> 3 ...

tru64/opt INFINITY warnung
hp complett
ibm ggf -qwarn64


es fehlt noch sowas wie sum of sets (Big Uninion)

macht es sinn  "idxset : sexpr condition" zu haben ?
condition kann in keiner weise auf das element zugreifen.

macht es einen Sinn param x[<i> in I ...] := 3 * i mit default zu haben.
Es sind doch alle indices initialisiert.

indexset sollte auch für variablen und parametergehen.
-----------------------

Mal überlegen ob es nicht eine ide wäre 
Metakontruckte eiinzuführen wie

IF x[i] > y[i] AND z[i] == 0 THEN
   x[i] + y[i] == 5
ELSE
   x[i] + y[i] + z[i] == 7
Was im prinzip ein bedingtes ODER ist.

   x[i] + y[i] == 5 OR x[i] + y[i] + z[i] == 7

------------------------------------------

Warnung bei set operationen auf sets mit inkompatiblen tupeln
z.B. { 1, 2, 3 } \ { "3" }

-------------------------------

Demangle script. das die .lp + .tbl für menschen lesbar macht.

----------------------------
Potenzmengen und mengen element kann dann auch eine menge sein,
so das man sagen kann:

forall w in pot(V) with s in W do

---------------------------------------------------
exists <a,b,c> in X : b == 4 and c == 3  shift/reduce beseitigen count?

Teilmengen zuweisung in sexpr

min <a,b> in X : expr 
max =====================> Dokumentation

include gucken auch innerhalt eines ; ausdrucks.


shortcummings and Tips&Trick Abschnitt

check statement mit forall als reductionsoperator expr* -> bool

Im LP reihenfolge der sets beibehalten

bessere fehlermeldungen

Warning wenn locale Variable eine globale uerbschreibt.
(Was passiert da eigendlich. Geht das überhaupt?)






