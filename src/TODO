Schnelleren hash-code von numb über nenner/zaehler
außerdem ggf im Tuple cachen.

AND OR XOR mit variablen einfach als audruck für binärvariablen erlauben.
z.b.  x[i] AND x[j] == 1


Schneller machen, insbesonder <i,p> in I wenn p schon gesetzt ist dauert viel zu lange. Direkten zugrif auf die submenge einrichten.

Einige Systeme zählen in check.sh nur die
ersten 16, dann nicht weiter.

Zugriff auf die Bounds der Variablen einbauen. Z.B. mit
getupper(x), getlower(x). Geht das überhaupt?

Bie sowas sollte es gehen daß das template wie <i, "xx", 1n> 
aussieht.

set A[<i> in I] := { read ipfile[i] as "<1n>" comment "#" };

gcov -f -b -o obj/O.linux.x86.gnu.gcov/ src/vinst.c
ist auch sehr geeignet um Statements und branches zu zählen.
Automatische auswertung ?

180 kann bei == kommen, wenn eine der Beiden Ungleichungen 
an der Bound liegt.
var x[I] integer >= -10 <= 10;
subto c1: vif x[1] <  0 then x[2] == 10 end;


Gibt es bei 180 einen false fall?

Improve position of error messages by giving the right child.

set.c testen ob bestimmte tuple automatisch in reihenfolge 
erzeugt werden. Wenn ja, markieren, damit binsearch eingesetzt 
werden kann. (z.B. range oder subset)

set.c SET_ADD_BEGIN wird nie genutzt.

105 kann auch von der Zielfunktion kommen.

Frage, wie bring man Kosten an den internen variablen an.
Idee:  VABS(..., "name");  VIF(..., name) vieleich dann doch
       VAND(a, b, "name);  VCMP(.... <= 5, "name") oder so
Dann Deklaration: var name binary bei den bool sachen und
                  var name integer bei vabs und dann wird
nichts erzeugt, sondern die angegebene variable benutzt. 

checken was passiert wenn man if bin_var == 1 then schreibt.

xor testen

überprüfen ob type() in der semantic von inst.h richtig ist


Mon sollte erkennen, das dies immer false ist
var x[I] integer >= -7 <= 0;
subto c1: vif x[1] + x[4] != 5 then x[2] + x[3] <= 7 end;


check und print in checks expr? einbauen
do print expr_list

check.sh für warning erweitern

test vergleich verbessern fuer 700er und 800er fehler.

trace wenn fehler in function?

cplex stream version? 
enter prob
zimpl -F cplex | awk 
getrennte -F's fuer .lp und .tbl ?

was passiert bei <i,i> in { <1,1>, <1,2>, <2,1>, <2,2> } = |2|{<1,1>,<1,2>,<2,1>,<2,2>} genau ?

warum gibt set A:= {1,"hallo", 2, "a"}; keine fehler ? soll das so? 

Warning 165 kommt nur wenn die Mengen die gleiche cardinalität haben.

check, that   -2^4 + 3! * 2 - 3 has the right value.

check fuer read/include siehe example

MPS testen auch ranges.

Funktion statistik Anzahl vars/Cons/Boxed/Fixed/NZOs etc, 
         (bei soplex/extr gibts schon so was)

Funktion timing.

defterm?
defcons?

Test mit 1 Mill var einbauen oder Sascha fragen
ewtl :    x1 + x2, x2 + x3, ... x98 + x99, x99 = 5 => preprocessing

if (....) constraint else constraint endif 
und/oder
if (....) term else term endif 
einbauen

unterstuetzung von semi-continous variablen in cplex

check mit fixierten variablen.

check separate flag

check: Tests für preprocessing

zugriff auf set elemente nach ordnungsnummer, so das
for <i> in { 1 .. card(A) } do
   A[ord(i)] 
geht.


Speedups:

numbgmp: mpq_clear aufrufen für verwendete oder schon erledigt.
strstore: string table, jeder nur einmal und dann handle. Macht auch
          str_has und str_cmp schneller.


auf explicite copys umstellen. list elem entry

numb = new_numb
elem = new_elem(numb);
tuple_new_tuple(elem);
free(elem);
free(numb);

nur noch 
tuple_new_tuple(new_elem(new_numb)));

und ansnsten hatlr

tuple_new_tuple(elem_copy(elem))));








Mindestens in Elem und Numb machen die SID wenig sinn,
weil sie nie zurueckgesetzt werden.

Einleseroutinen für indizerte Sets

tru64/opt INFINITY warnung
ibm ggf -qwarn64


es fehlt noch sowas wie sum of sets (Big Uninion)

macht es sinn  "idxset : sexpr condition" zu haben ?
condition kann in keiner weise auf das element zugreifen.

macht es einen Sinn param x[<i> in I ...] := 3 * i mit default zu haben.
Es sind doch alle indices initialisiert.

indexset sollte auch für variablen und parametergehen.
-----------------------

Mal überlegen ob es nicht eine ide wäre 
Metakontruckte eiinzuführen wie

IF x[i] > y[i] AND z[i] == 0 THEN
   x[i] + y[i] == 5
ELSE
   x[i] + y[i] + z[i] == 7
Was im prinzip ein bedingtes ODER ist.

   x[i] + y[i] == 5 OR x[i] + y[i] + z[i] == 7

------------------------------------------

Warnung bei set operationen auf sets mit inkompatiblen tupeln
z.B. { 1, 2, 3 } \ { "3" }

-------------------------------

Demangle script. das die .lp + .tbl für menschen lesbar macht.

----------------------------
Potenzmengen und mengen element kann dann auch eine menge sein,
so das man sagen kann:

forall w in pot(V) with s in W do

---------------------------------------------------
exists <a,b,c> in X : b == 4 and c == 3  shift/reduce beseitigen count?

Teilmengen zuweisung in sexpr

min <a,b> in X : expr 
max =====================> Dokumentation

include gucken auch innerhalt eines ; ausdrucks.


shortcummings and Tips&Trick Abschnitt

Im LP reihenfolge der sets beibehalten







