Bug in par initialisierung.
es wird diret das set von idxset genommen. Dann geht aber 
<1,i> in B schief. set_from_idxset verwenden.


Sollte man auf 0 fixierte Variablen entfernen ?
------------------------
idxset und sexpr vereinheitlichen, eigendlich ist ein
idxset immer eine sexpr

Mal überlegen ob es nicht eine ide wäre 
Metakontruckte eiinzuführen wie

IF x[i] > y[i] AND z[i] == 0 THEN
   x[i] + y[i] == 5
ELSE
   x[i] + y[i] + z[i] == 7
Was im prinzip ein bedingtes ODER ist.

   x[i] + y[i] == 5 OR x[i] + y[i] + z[i] == 7

------------------------------------------

lint: check bei passes(2+)

Initialisierung von set's

1. Indizierung der sets erlauben.

Warnung bei set operationen auf sets mit inkompatiblen tupeln
z.B. { 1, 2, 3 } \ { "3" }

-------------------------------

Demangle script. das die .lp + .tbl für menschen lesbar macht.

Flag für make_tmpname in lpfwrite das angibt ob der Name gemangelt oder
korrekt als x["hallo",5] ausgegeben werden soll.

----------------------------
Potenzmengen und mengen element kann dann auch eine menge sein,
so das man sagen kann:

forall w in pot(V) with s in W do

---------------------------------------------------
exists <a,b,c> in X : b == 4 and c == 3  shift/reduce beseitigen count?

Teilmengen zuweisung in sexpr

min <a,b> in X : expr 
max =====================> Dokumentation

include gucken auch innerhalt eines ; ausdrucks.

ewtl bei lp_format etwas längere Dateinamen

default für parameter

shortcummings and Tips&Trick Abschnitt

check statement mit forall als reductionsoperator expr* -> bool

Im LP reihenfolge der sets beibehalten

bessere fehlermeldungen

Warning wenn locale Variable eine globale uerbschreibt.

sparse symbols. Dazu brauchen wir das urspüngliche indexset.
Dann können wir für alle derefs mit einem index für den kein Wert
vorliegt, der aber zulässig wäre, den default zurück liefern.





