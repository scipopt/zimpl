Mon sollte erkennen, das dies immer false ist
var x[I] integer >= -7 <= 0;
subto c1: vif x[1] + x[4] != 5 then x[2] + x[3] <= 7 end;


check dokumentieen
check und print in checks expr? einbauen
do print expr_list

check.sh für warning erweitern

test vergleich verbessern fuer 700er und 800er fehler.

trace wenn fehler in function?

cplex stream version? 
enter prob
zimpl -F cplex | awk 
getrennte -F's fuer .lp und .tbl ?

was passiert bei <i,i> in { <1,1>, <1,2>, <2,1>, <2,2> } = |2|{<1,1>,<1,2>,<2,1>,<2,2>} genau ?

warum gibt set A:= {1,"hallo", 2, "a"}; keine fehler ? soll das so? 

Warning 165 kommt nur wenn die Mengen die gleiche cardinalität haben.

check, that   -2^4 + 3! * 2 - 3 has the right value.

check fuer read/include siehe example

MPS testen auch ranges.

Funktion statistik Anzahl vars/Cons/Boxed/Fixed/NZOs etc, 
         (bei soplex/extr gibts schon so was)

Funktion timing.

defterm?
defcons?

Test mit 1 Mill var einbauen oder Sascha fragen
ewtl :    x1 + x2, x2 + x3, ... x98 + x99, x99 = 5 => preprocessing

if (....) constraint else constraint endif 
und/oder
if (....) term else term endif 
einbauen

unterstuetzung von semi-continous variablen in cplex

check mit fixierten variablen.

check separate flag

check: Tests für preprocessing

zugriff auf set elemente nach ordnungsnummer, so das
for <i> in { 1 .. card(A) } do
   A[ord(i)] 
geht.


Speedups:

numbgmp: mpq_clear aufrufen für verwendete oder schon erledigt.
strstore: string table, jeder nur einmal und dann handle. Macht auch
          str_has und str_cmp schneller.


auf explicite copys umstellen. list elem entry

numb = new_numb
elem = new_elem(numb);
tuple_new_tuple(elem);
free(elem);
free(numb);

nur noch 
tuple_new_tuple(new_elem(new_numb)));

und ansnsten hatlr

tuple_new_tuple(elem_copy(elem))));








Mindestens in Elem und Numb machen die SID wenig sinn,
weil sie nie zurueckgesetzt werden.

Einleseroutinen für indizerte Sets

tru64/opt INFINITY warnung
ibm ggf -qwarn64


es fehlt noch sowas wie sum of sets (Big Uninion)

macht es sinn  "idxset : sexpr condition" zu haben ?
condition kann in keiner weise auf das element zugreifen.

macht es einen Sinn param x[<i> in I ...] := 3 * i mit default zu haben.
Es sind doch alle indices initialisiert.

indexset sollte auch für variablen und parametergehen.
-----------------------

Mal überlegen ob es nicht eine ide wäre 
Metakontruckte eiinzuführen wie

IF x[i] > y[i] AND z[i] == 0 THEN
   x[i] + y[i] == 5
ELSE
   x[i] + y[i] + z[i] == 7
Was im prinzip ein bedingtes ODER ist.

   x[i] + y[i] == 5 OR x[i] + y[i] + z[i] == 7

------------------------------------------

Warnung bei set operationen auf sets mit inkompatiblen tupeln
z.B. { 1, 2, 3 } \ { "3" }

-------------------------------

Demangle script. das die .lp + .tbl für menschen lesbar macht.

----------------------------
Potenzmengen und mengen element kann dann auch eine menge sein,
so das man sagen kann:

forall w in pot(V) with s in W do

---------------------------------------------------
exists <a,b,c> in X : b == 4 and c == 3  shift/reduce beseitigen count?

Teilmengen zuweisung in sexpr

min <a,b> in X : expr 
max =====================> Dokumentation

include gucken auch innerhalt eines ; ausdrucks.


shortcummings and Tips&Trick Abschnitt

Im LP reihenfolge der sets beibehalten







