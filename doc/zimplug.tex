% $Id: zimplug.tex,v 1.21 2004/06/17 08:18:33 bzfkocht Exp $
%* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
%*                                                                           *
%*   File....: zimplug.tex                                                   *
%*   Name....: Zimpl User Guide                                              *
%*   Author..: Thorsten Koch                                                 *
%*   Copyright (C) 2003 by Author, All rights reserved                       *
%*                                                                           *
%* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
%
\section{Introduction}
A linear program (\lp) might look like this:
$$
\begin{array}{rll}
\min& 2 x + 3 y\\
\mbox{subject to}& x + y& \leq 6\\
&x,y&\ge 0\\
\end{array}
$$
The usual format to store the description of such a problem is \mps
invented by \ibm \citep[see the][]{IBM1997} long ago. 
Nearly all available \lp and \mip solvers can read this format.
While \mps is a nice format to punch into a punch card and at least a
reasonable format to read for a computer it is quite unreadable
for humans. 

{
\small
\begin{verbatim}
   NAME        ex1.mps
   ROWS
    N  OBJECTIV          
    L  c1                
   COLUMNS
       x         OBJECTIV             2
       x         c1                   1
       y         OBJECTIV             3
       y         c1                   1
   RHS
       RHS       c1                   6
   ENDATA
\end{verbatim}
}
Another possibility is the \lpf format \cite{CPlex80}, which is more
readable\footnote{
The \lpf format has also some idiosyncratic restrictions. For example
variables should not be named \code{e12} or the like. And it is not
possible to specify ranged constraints.}
but is only supported by a few solvers. 
{
\small
\begin{verbatim}
   Minimize
    cost:  +2 x +3 y
   Subject to
    c1:  +1 x +1 y <= 6
   End
\end{verbatim}
}
But since each coefficient of the matrix $A$ must be stated
explicitly it is also not a desirable choice to develop a mathematical
model.

\medskip
Now, with \zimpl it is possible to write this:
{\small
\begin{verbatim}
   var x;
   var y;
   minimize cost: 2 * x + 3 * y;
   subto c1: x + y <= 6;
\end{verbatim}
}
and have it automatically translated into \mps or \lpf format.
While this looks not much different from what is in the \lpf format,
the difference can be seen, if we use indexed variables.
Here is an example. This is the \lp 
$$
\begin{array}{rl}
\min& 2 x_1 + 3 x_2 + 1.5 x_3\\
\mbox{subject to}&\sum^3_{i=1} x_i \leq 6\\
&x_i\ge 0\\
\end{array}
$$
And this is how to tell it to \zimpl
{
\small
\begin{verbatim}
set I      := { 1 to 3 };
param c[I] := <1> 2, <2> 3, <3> 1.5;
var   x[I] >= 0;
minimize cost: sum <i> in I : c[i] * x[i];
subto    cons: sum <i> in I : x[i] <= 6;
\end{verbatim}
}

% -----------------------------------------------------------------------------
% --- Invocation
% -----------------------------------------------------------------------------
\section{Invocation}

To run \zimpl on a model given in the file \code{ex1.zpl} type the command
\begin{verbatim}
   zimpl ex1.zpl
\end{verbatim}

The general case is \code{zimpl} \code{[options]} $<$\code{input-files}$>$.

\medskip
It is possible to give more than one input file. They are read one
after the other as if they were all one big file.
If any error occurs while processing, \zimpl will print out an 
error message and abort. In case everything goes well, the results 
will be written into two or more files, depending on the options specified.

The first file is the problem generated from the model in either 
\lpf or \mps format with extension \code{.lp} or \code{.mps}.
The next one is the ``table'' file, which has the extension \code{.tbl}.
This file lists all variable and constraint names used in the model 
and their corresponding names in the problem file. 

The reason for this name translation is that the \mps format
can only handle names up to eight characters long. Also the the \lp format
restricts the length of names. The precise limit is depending on the
version. \cplex~7.0 has a limit of 16 characters, and ignores
silently the rest of the name, while \cplex~9.0 has a limit of 255
characters, but will ony show the first 20 in the output of some commands.

%The third file is and optional \cplex branching order file.

\medskip
The following options are possible (only the first two are normally
of interest):

\medskip
\begin{tabular}{lp{105mm}}
%\hline
-t \emph{format} & Selects the output format. Can be either \code{lp}
                  which is default, or \code{mps} or \code{hum} which
                  is only human readable.\\
-o \emph{name}   & Sets the base-name for the output files.\\ 
                & Defaults to the name of the first input file stripped 
                  off its path and extension.\\ 
-F \emph{filter} & The output is piped through a filter. A \%s in the
                  string is replaced by the output filename. For example 
                  \code{-F "gzip -c >\%s.gz"} would compress all the 
                  output files.\\
-n \emph{cform}  & Select the format for the generation of constraint
                  names. Can be either \emph{cm} which will number them 
                  $1\ldots n$ with a `c' in front. \emph{cn} will use 
                  the name supplied in the \code{subto} statement and 
                  number them $1\ldots n$ within the statement. 
                  \emph{cf} will use the name given with the \code{subto},
                  then a $1\ldots n$ number like in \emph{cm} and then 
                  append all the local variables from the forall statements.\\
-v \emph{1..5}   & Set the verbosity level. 0 is quiet, 1 is default,
                  2 is verbose, 3 is chatter, and 5 is debug.\\
-D \emph{name=val} & Sets the parameter \emph{name} to the specified
                  value. This is equivalent with having this line in the
                  \zimpl program: \code{param name:=val}.\\
%\hline
-b & Enables bison debugging output.\\
-f & Enables flex debugging output.\\
-h & Prints a help message.\\
-m & Writes a \cplex \code{mst} Mip STart file.\\
-O & Optimize the generated \lp by doing some presolve analysis.\\
-r & Writes a \cplex \code{ord} branching order file.\\
-V & Prints the version number.\\
%\hline
\end{tabular}

\medskip
A typical invocation is for example:
\begin{verbatim}
   zimpl -o hardone -t mps data.zpl model.zpl
\end{verbatim}
This reads the files \code{data.zpl} and \code{model.zpl} and
produces \code{hardone.mps} and \code{hardone.tbl}.

\medskip
\fbox{\parbox{0.9\textwidth}{
If \mps-output is specified for a maximization problem,
the objective function will be inverted.}}
% -----------------------------------------------------------------------------
% --- Format
% -----------------------------------------------------------------------------
\section{Format}

Each \zpl-file consists of six types of statements: 
\begin{itemize}
\item Sets
\item Parameters
\item Variables
\item Objective
\item Constraints
\item Function definitions
\end{itemize}

Each statement ends with a semicolon \code{;}. 
Everything from a number-sign \code{\#} to 
the end of the line is treated as a
comment and is ignored.

If a line starts with the word \code{include} followed by a filename in double
quotation marks then this file is read instead of the line.

%-----------------------------------------------------------------------------------------
\subsection{Expressions}
%-----------------------------------------------------------------------------------------
\zimpl works on its lowest level with two types of data: Strings and
numbers. 

Wherever a number or string is required, it is also possible to use a
parameter of the corresponding value type. Usually, expressions are
allowed instead of just a number or a string.
The precedence of operators should be the usual one, but
parenthesis can always be used to specify the evaluation order explicitly.
If in doubt use parenthesis.

\subsubsection{Numeric expressions}
A number in \zimpl can be given in the usual format, \eg as 2, -6.5 or 5.234e-12. 
Numeric expressions consist of numbers, numeric valued parameters, and
any of the following operators and functions:

\begin{tabular}{lll}
\code{a${}^\wedge$b}, \code{a**b}&$a$ to the power of $b$   & $a^b$\\
\code{a+b}                       &addition                  & $a+b$\\
\code{a-b}                       &subtraction               & $a-b$\\
\code{a*b}                       &multiplication            & $a\cdot b$\\
\code{a/b}                       &division                  & $a/b$\\
\code{a mod b}                   &modulo                    & $a\mod b$\\
\code{a div b}                   &integer division           & \\
\code{abs(a)}                    &absolute value            & $|a|$\\
\code{floor(a)}                  &round down                & $\lfloor a\rfloor$\\
\code{ceil(a)}                   &round up                  & $\lceil a\rceil$\\
\code{a!}                        &factorial                 & $a!$\\
\code{min(S)}                    &minimum of a set          &$\min_{s\in S}$\\
\code{max(S)}                    &maximum of a set          &$\max_{s\in S}$\\
\code{min(a,b,c,\ldots,n)}       &minimum of a list         &$\min (a,b,c,\ldots,n)$\\
\code{max(a,b,c,\ldots,n)}       &maximum of a list         &$\max (a,b,c,\ldots,n)$\\
\code{card(S)}                   &cardinality of a set      &$|S|$\\
\code{ord(A,n,c)}                &ordinal                   &c-th component of the n-th\\ 
                                 &                          & element of set $A$.\\
\code{if a then b else c}        &conditional               &\\
\end{tabular}

\medskip
%With $\min$ and $\max$ it is possible to find the minimum/maximum
%member of an one dimensional set of numeric values.
%\code{card} gives the cardinality of a set.

The following functions are only computed with normal double precision
floating point arithmetic. So be careful:

\medskip
\begin{tabular}{lll}
\code{sqrt(a)}                   &square root               & $\sqrt a$\\
\code{log(a)}                    &logarithm to base 10      & $\log_{10}a$\\
\code{ln(a)}                     &natural logarithm         & $\ln a$\\
\code{exp(a)}                    &exponential function      & $e^a$\\
%\code{random(a,b)}               &random number in $\left[a,b\right]$&\\
\end{tabular}


\subsubsection{String expressions}
A string is delimited by double quotation marks \code{"},
\eg, \code{"Hallo"}. 

\subsubsection{Variant expressions}
The following is either a numeric or a string expression, depending if
\emph{expression} is a string or a numeric expression.

\code{if} \emph{boolean-expression} \code{then}
\emph{expression} \code{else} \emph{expression} \code{end}.

The same is true for the
\code{ord}\emph{(set,tuple-number,component-number)} function, 
which evaluates to a specific element of a set. Please note, that
sets have no specific order.

\subsubsection{Boolean expressions}
These evaluate either to \emph{true} or \emph{false}. For numbers and
strings the
relational operators $<$, $<=$, $==$, $!=$, $>=$, and $>$ are
defined.
Combinations of boolean expressions with \code{and},
\code{or}, and 
\code{xor}\footnote{$a\wedge\bar{b}\vee \bar{a}\wedge b$} 
and negation with \code{not} are possible.
The expression \emph{tuple} \code{in} \emph{set-expression} can be used to test set
membership of a tuple. 

\subsection{Sets}
Sets consist of tuples. The tuples in a sets are unordered, \ie, each tuple can only
be once in a set. Sets are delimited by braces, \code{\{} and \code{\}},
resp.
Tuples consist of components. The components are ordered. 
Each tuple of a specific set has the same number of components. 
The components are either numbers or strings. The type of the $n$-th
component for all tuples of a set must be the same. A tuple starts and ends with
$<$ and $>$, resp., \eg \code{$<$1,2,"x"$>$}. The components are separated by commas.
If tuples are one-dimensional, it is possible 
to omit the tuple delimiters in a list of elements, but then 
they must be omitted from all tuples of the set, \eg \code{\{1,2,3}\}.

Sets can be defined with the set statement. It consists of
the keyword \code{set}, the name of the set, an assignment operator
(\code{:=}) and a valid set expression.

Sets are referenced by use of an \emph{template} tuple, consisting
of placeholders that are replaced by the value of the components of
the respective tuple. For example a set $S$ consisting of two-dimensional
tuples could be referenced by \code{<a,b> in S}. If any of the
placeholders are actual values, only those tuples will be extracted
that match these values. For example \code{<1,b> in S} will only get
those tuples whose first component is \code{1}. Please note that if
one of the placeholders is the name of an already defined parameter,
set or variable, it will be substituted. This will result either in an
error or an actual value.

\paragraph{Examples}
{\small 
\begin{verbatim}
set A := { 1, 2, 3 };
set B := { "hi", "ha", "ho" };
set C := { <1,2,"x">, <6,5,"y">, <787,12.6,"oh"> };
\end{verbatim}
}

For set expressions these functions and
operators are defined:

\medskip
\begin{tabular}{llp{5cm}}
%\hline
\code{A*B},&\\
\code{A cross B}   &Cross product & $\{(x,y)| x\in A\wedge y\in B\}$\\
\code{A+B},&\\
\code{A union B}   &Union & $\{x | x\in A\vee x\in B\}$\\
\code{A inter B}   &Intersection & $\{x |x\in A\wedge x\in B\}$\\
\code{A$\setminus$B, A-B},&\\
\code{A without B} &Difference & $\{ x |x\in A\wedge x\not\in B\}$\\
\code{A symdiff B} &Symmetric difference & 
   $\{ x |(x\in A\wedge x\not\in B)\vee(x\in B\wedge x\not\in A)\}$\\
\code{\{n\,{..}\,m\}},&\\
\code{\{n to m \emph{by s}\}}& Generate, & 
   $\{ x | x=n + is \leq m, i\in\N_0\}$\\
   &(default $s = 1$)&\\ 
\code{proj(A, t)}& Projection & 
   The new set will consist of $n$-tuples, with\\
   &$t=(e_1,\ldots,e_n)$&
   the $i$-th component being the $e_i$-th component of $A$.\\
\code{if a then}\\
\code{\ b else c}        &Conditional               &\\
%\hline
\end{tabular}

\medskip
An example for the use of the \code{if} \emph{boolean-expression} \code{then}
\emph{set expression} \code{else} \emph{set expression} \code{end} can
be found below with the examples for indexed sets.

\paragraph{Examples}
{\small 
\begin{verbatim}
set D := A cross B;
set E := { 6 to 9 } union A without { <2>, <3> }; 
set F := { 1 to 9 } * { 10 to 19 } * { "A", "B" };
set G := proj(F, <3,1>) 
# will give: <"A",1>, <"A",2"> ... <"B",9>
\end{verbatim}
}

\subsubsection{Conditional sets}
It is possible to restrict a set to tuples that 
satisfy a boolean expression. The expression given by the \code{with}
clause is evaluated for each tuple in the set and only tuples for
which the expression evaluated to \emph{true} are included in the new set.

\paragraph{Examples}
{\small 
\begin{verbatim}
set F := { <i,j> in Q with i > j and i < 5 };
set A := { "a", "b", "c" };
set B := { 1, 2, 3 };
set V := { <a,2> in A*B with a == "a" or a == "b" };
# will give: <"a",2>, <"b",2>
\end{verbatim}
}


\subsubsection{Indexed sets}
It is possible to index one set with another set.
Here is a list of functions that use this:

\medskip
\begin{tabular}{llp{5cm}}
\code{powerset(A)}& Generates all subsets of $A$&$\{X | X\subseteq A\}$\\
\code{subset(A,n)}& Generates all subsets of $A$\\
                    & with $n$ elements&$\{X | X\subseteq A\wedge |X|=n\}$\\
\code{indexset(A)}&The index set of $A$&$\{1\ldots |A|\}$\\
\end{tabular}

\medskip
Indexed sets are accessed by adding the index of the set in brackets
\code{[} and \code{]}, like \code{S[7]}. 
There are three possibilities how to assign to an indexed set:
\begin{itemize}
\item The assignment expression is a list of comma separated pairs, 
      consisting of a tuple from the index set and a set expression to assign.
\item A set reference expression is given as index, then
      the assignment expression is evaluated for each index tuple.
\item By use of a function that returns an indexed set.
\end{itemize}

\subsubsection{Examples}
{\small 
\begin{verbatim}
set I           := { 1..3 };
set A[I]        := <1> { "a", "b" }, 
                   <2> { "c", "e" }, <3> { "f" };
set B[<i> in I] := { 3 * i };
set P[]         := powerset(I);
set J           := indexset(P);
set S[]         := subset(I, 2);
set K[<i> in I] := if i mod 2 == 0 then { i } else { -i } end;
\end{verbatim}
}

%------------------------------------------------------------------------------
\subsection{Parameters}
%------------------------------------------------------------------------------
Parameters can be declared with or without an indexing
set. Without indexing the parameter is just one value, which is either
a number or a string. For indexed parameters there is one
value for each member of the set. It is possible to declare a
\emph{default} value.

Parameters are declared in the following way: 
The keyword \code{param} is followed by the name of the parameter
optionally followed by the indexing set. 
Then after the assignment sign comes a list of pairs. The first element of each
pair is a tuple from the index set, the second element is the value of
the parameter for this index.

\subsubsection{Examples}
{\small 
\begin{verbatim}
set A := { 12 .. 30 };
set C := { <1,2,"x">, <6,5,"y"> };
param q := 5;
param u[A] := <1> 17, <2> 29, <3> 12 default 99;
param w[C] := <1,2,"x"> 1/2, <6,5,"y"> 2/3;
param x[<i> in { 1 .. 8 } with i mod 2 == 0] := 3 * i;
\end{verbatim}
}

\medskip
In the example, no value is given for index $<$787,12.6,"oh"$>$ of
parameter \code{w}, that is assignments need not to be complete. This
is correct as long as it is never referenced.

\subsubsection{Parameter tables}
It is possible to initialize multi-dimensional indexed parameters from
tables. This is especially useful for two-dimensional parameters.
The data is put in a table structure with \code{$|$} signs on each
margin. Then a head line with column indices has to be added, and one index
for each row of the table is needed. The column index has to be
one-dimensional, but the row index can be
multi-dimensional. The complete index for the entry is built by
appending the column index to the row index.
The value entries are separated by commas. Any valid expression is
allowed here. As can be seen in the third example below, it is
possible to add a list of entries after the table.

\subsubsection{Examples}
{\small 
\begin{verbatim}
set I := { 1 .. 10 };
set J := { "a", "b", "c", "x", "y", "z" };

param h[I*J] :=   | "a", "c", "x", "z"   |
                |1|  12,  17, 99,     23 |
                |3|   4,   3,-17, 66*5.5 |
                |5| 2/3, -.4,  3, abs(-4)|
                |9|   1,   2,  0,      3 | default -99;

param g[I*I*I] :=     | 1, 2, 3 |
                  |1,1| 0, 1, 0 |
                  |1,2| 1, 1, 1 |
                  |1,3| 0, 0, 1 | 
                  |2,1| 1, 0, 1 |;

param k[I*I] :=  |  7,  8,  9 |
               |4| 89, 67, 55 |
               |5| 12, 13, 14 |, <1,2> 17, <3,4> 99;
\end{verbatim}
}

%------------------------------------------------------------------------------
\subsection{Variables}
%------------------------------------------------------------------------------
Like parameters, variables can be indexed. 
A variable has to be one out of three possible types: 
Continuous (called \emph{real}), binary or integer. The default is real. 
Variables may have lower and upper bounds. Defaults are
zero as lower and infinity as upper bound. Binary variables are
always bounded between zero and one.
It is possible to compute the value of the lower or upper bounds
depending on the index for the variable (see last declaration in the
example). Bounds can also be set to \code{infinity} and \code{-infinity}.

\subsubsection{Examples}
{\small 
\begin{verbatim}
var x1;
var x2 binary;
var y[A] real >= 2 <= 18;
var z[<a,b,c> in C] integer 
    >= a * 10 
    <= if b <= 3 then p[b] else 10 end; 
\end{verbatim}
}

\fbox{Remember: if nothing is specified a lower bound of zero is assumed.}

\subsection{Objective}
There must be at most one objective statement in a model. The objective
can be either \code{minimize} or \code{maximize}. Following the
keyword is a name, a colon (\code{:}) and then a term consisting 
of variables.

\subsubsection{Example}
{\small 
\begin{verbatim}
minimize cost: 12 * x1 -4.4 * x2 
   + sum <a> in A : u[a] * y[a]
   + sum <a,b,c> in C with a in E and b > 3 : -a/2 * z[a,b,c];
\end{verbatim}
}

%------------------------------------------------------------------------------
\subsection{Constraints}
%------------------------------------------------------------------------------
The general format for a constraint is
\verb|subto name: term sense term|.\\
Name can be any name starting with a letter. The term is defined
as in the objective. Sense is one of
\code{<=}, \code{>=} and \code{==}. 
Many constraints can be generated with one statement by the use of the
\code{forall} instruction, see below.

\subsubsection{Examples}
{\small 
\begin{verbatim}
subto time : 3 * x1 + 4 * x2 <= 7;
subto space: sum <a> in A : 2 * u[a] * y[a] >= 50;
subto weird: forall <a> in A : 
   sum <a,b,c> in C : z[a,b,c] == 55;
subto c21: 6 * (sum <i> in A : x[i] 
   + sum <j> in B : y[j]) >= 2;
subto c40: x[1] == a[1] + 
   2 * sum <i> in A do 2*a[i]*x[i]*3 + 4;
\end{verbatim}
}

%------------------------------------------------------------------------------
\subsection{Details on \code{sum} and \code{forall}}
%------------------------------------------------------------------------------
The general forms are

\qquad\code{forall} \emph{index} \code{do} \emph{term}
and 
\code{sum} \emph{index} \code{do} \emph{term}.
 
It is possible to nest several forall instructions.
%It should be noted, that a \code{sum}-expression is a \emph{term}
%itself, so it is possible to nest or concatenate them.
The general form of \emph{index} is 

\qquad\emph{tuple} \code{in} \emph{set} \code{with} \emph{boolean-expression}.

It is allowed to write a colon (\code{:}) instead of \code{do} and a
vertical bar (\code{|}) instead of \code{with}.
The number of components in the \emph{tuple} and in the components of the
members of the \emph{set} must match. The \code{with} part of an \emph{index} is
optional. The \emph{set} can be any expression giving a set.

\subsubsection{Examples}
{\small 
\begin{verbatim}
forall <i,j> in X cross { 1 to 5 } without { <2,3> } 
   with i > 5 and j < 2 do 
      sum <i,j,k> in X cross { 1 to 3 } cross Z do 
         p[i] * q[j] * w[j,k] >= if i == 2 then 17 else 53;
\end{verbatim}
}

Note that in the example \emph{i} and \emph{j} are set by the \code{forall}
instruction. So they are fixed for all invocations of \code{sum}.

%------------------------------------------------------------------------------
\subsection{Details on \code{if} in constraints}
%------------------------------------------------------------------------------
It is possible to put two variants of a constraint into an
\code{if}-statement. The same applies  for \emph{terms}.
It is also possible to have a \code{forall} statement inside
the result part of an \code{if}.

\subsubsection{Examples}
{\small 
\begin{verbatim}
subto c1: forall <i> in I do
  if (i mod 2 == 0) then  3 * x[i] >= 4
                    else -2 * y[i] <= 3 end;
subto c2: sum <i> in I :
     if (i mod 2 == 0) then 3 * x[i] else -2 * y[i] end <= 3;
\end{verbatim}
}


%------------------------------------------------------------------------------
\subsection{Initializing sets and parameters from a file}
%------------------------------------------------------------------------------
It is possible to load the values for a set or a parameter from a
file. The syntax is

\smallskip
\code{read} \emph{filename} \code{as} \emph{template} 
[\code{skip} \emph{n}] [\code{use} \emph{n}] 
[\code{fs} \emph{s}] [\code{comment} \emph{s}]

\smallskip
\emph{filename} is the name of the file to read.

\emph{template} is a string with a template for the tuples to
generate. Each input line from the file is split into fields. The
splitting is done according to the following rules:
Whenever a space, tab, comma, semicolon or double colon is encountered
a new field is started. Text that is enclosed in double quotes is not
split, the quotes are always removed. When a field is split all space
and tab characters around the splitting are removed. If the split is
due to a comma, semicolon or double colon, each occurrence of these
characters starts a new field. 

\subsubsection{Examples}
{\small 
All these lines have three fields:
\begin{verbatim}
Hallo;12;3    
Moin   7  2
"Hallo, Peter"; "Nice to meet you" 77
,,2
\end{verbatim}
}

For each component of the tuple, the number of the field
to use for the value is given, followed by either an \code{n} if the
field should be interpreted as a number or \code{s} for a string. 
Have a look at the example, it is quite obvious how it works.
After the template some optional modifiers can be given. The order
does not matter. 

\code{skip} \emph{n} instructs to skip the first
\emph{n} lines of the file. 

\code{use} \emph{n} limits the number of
lines to use to \emph{n}. 

\code{comment} \emph{s} sets a list of characters that start
comments in the file. Each line is ended when any of the comment
characters is found.

When a file is read, empty lines are skipped and not counted for the
\code{use} clause. They are counted for the \code{skip} clause.
 
\subsubsection{Examples}
{\small 
\begin{verbatim}
set P := { read "nodes.txt" as "<1s>" };

nodes.txt:
   Hamburg   ->   <"Hamburg">
   München   ->   <"München">
   Berlin    ->   <"Berlin">

set Q := { read "blabla.txt" as "<1s,5n,2n>" skip 1 use 2 };

blabla.txt:
   Name;Nr;X;Y;No     ->   skip   
   Hamburg;12;x;y;7   ->   <"Hamburg",7,12>
   Bremen;4;x;y;5     ->   <"Bremen,5,4>
   Berlin;2;x;y;8     ->   skip
   
param cost[P] := read "cost.txt" as "<1s> 2n" comment "#";

cost.txt:
   # Name Price   ->   skip
   Hamburg 1000   ->   <"Hamburg"> 1000
   München 1200   ->   <"München"> 1200
   Berlin  1400   ->   <"Berlin">  1400

param cost[Q] := read "haha.txt" as "<3s,1n,2n> 4s";

haha.txt:
   1:2:ab:con1    ->   <"ab",1,2> "con1"
   2:3:bc:con2    ->   <"bc",2,3> "con1"
   4:5:de:con3    ->   <"de",4,5> "con1"
\end{verbatim}
}  

As with table format input, it is possible to add a list of tuples or
parameter entries after a read statement.
\subsubsection{Examples}
{\small 
\begin{verbatim}
set A := { read "test.txt" as "<2n>", <5>, <6> }; 
param winniepoh[X] := 
   read "values.txt" as "<1n,2n> 3n", <1,2> 17, <3,4> 29;
\end{verbatim}
}  


%------------------------------------------------------------------------------
\subsection{Function Definitions}
%------------------------------------------------------------------------------
It is possible to define functions within \zimpl. The value a
function returns has to be either a number, a string or a set.
The arguments of a function can only be numbers or strings, but within
the function definition it is possible to access all otherwise
declared sets, parameters and variables.

The definition of a function has to start with 
\code{defnumb}, \code{defstrg} or \code{defset}, depending on the
return value.
Then follows the name
of the function and a list of argument names put in parenthesis.

After this comes an assignment operator (\code{:=}) and a valid
expression or set expression.

\subsubsection{Examples}
{\small 
\begin{verbatim}
defnumb dist(a,b)  := a*a + b*b;
defstrg huehott(a) := if a < 0 then "hue" else "hott" end;
defset  bigger(i)  := { <j> in K with j > i };
\end{verbatim}
}


%------------------------------------------------------------------------------
\subsection{Extended Constraints (experimental)}
%------------------------------------------------------------------------------
\zimpl has the possibility to generate systems of constraints that
mimic conditional constraints. The general syntax is as  follows, note
that the \code{else} part is optional:

\smallskip
\centerline{
\code{vif} \emph{boolean-constraint} \code{then} \emph{constraint} 
[ \code{else} \emph{constraint} ] \code{end}}

\smallskip
where \emph{boolean-constraint} consists of linear expression involving
variables. All these variables have to be bounded integer or binary
variables. It is not possible to use any continuous variables or integer
variables with infinite bounds in a boolean-constraint.
All comparison operators ($<$, $\le$, $==$, $!\!\!\!=$, $\ge$, $>$) are
allowed. Also combination of several terms with \code{and},
\code{or}, and \code{xor} and negation with \code{not} is possible.
The conditional constraints (those which follow after \code{then} or
\code{else}, may include bounded continuous variables. 
\begin{center}
\fbox{\parbox{0.85\textwidth}{Be aware that using this construct will lead to
the generation of several additional constraints and variables.}}
\end{center}
\subsubsection{Examples}
{\small 
\begin{verbatim}
var x[i] integer >= 0 <= 20;

subto c1: vif 3 * x[1] + x[2] != 7 
   then sum <i> in I : y[i] <= 17
   else sum <k> in K : z[k] >= 5 end;

subto c2: vif x[1] == 1 and x[2] > 5 then x[3] == 7 end;

subto c3: forall <i> in I : 
             vif x[i] >= 2 then x[i + 1] <= 4 end;
\end{verbatim}
}


%------------------------------------------------------------------------------
\subsection{Extended Functions (experimental)}
%------------------------------------------------------------------------------
It is possible to use special functions on terms with variables that
will automatically converted to a system of inequalities. The
arguments of these functions have to be linear terms consisting of
bounded integer or binary variables. 

The following functions are defined:

\medskip
\begin{tabular}{llp{7cm}}
%\hline
\code{vabs(t)}&Absolute value&$|t|$\\
%\hline
\end{tabular}

\begin{center}
\fbox{\parbox{0.85\textwidth}{Be aware that using this construct will lead to
the generation of several additional constraints and variables.}}
\end{center}

\subsubsection{Examples}
{\small 
\begin{verbatim}
var x[i] integer >= -5 <= 5;

subto c1: vabs(x[1]) >= 5;
subto c2: vabs(sum <i> in I : x[i]) <= 15;
subto c2: vif vabs(x[1] + x[2]) > 2 then x[3] == 7 end;
\end{verbatim}
}

%------------------------------------------------------------------------------
\subsection{The \code{do print} and \code{do check} commands}
%------------------------------------------------------------------------------
The \code{do} command is special.
It has two possible incarnations:

\code{print} and \code{check}. \code{print} will print to the 
standard output stream
whatever numerical, string, Boolean or set expression, or tuple
follows it. This can be used for example to check if a set has the
expected members, or if some computation has the anticipated result.

\code{check} always precedes a Boolean expression. If this
expression does not evaluated to \emph{true}, the program is aborted
with an appropriate error message. This can be used to assert that
specific conditions are met.

It is possible to use a \code{forall} clause before a \code{print}
oder \code{check} statement.

\subsubsection{Examples}
{\small 
\begin{verbatim}
set I := { 1..10 };

do print I;
do forall <i> in I with i > 5 do print sqrt(i);

do forall <p> in P do check sum <p,i> in PI : 1 >= 1;
\end{verbatim}
}

\clearpage
\section{Examples}
In this section we will show examples how to translate a problem
into \zimpl format.

\subsection{Diet problem}
This is the first example in 
\cite[Chapter 1, page 3]{Chvatal1983}.
It is a classic so-called \emph{diet}-problem, see for example
\cite{Danzig1990} about the practicle implications.

Given a set of foods $F$ and a set of nutrients $N$, we have a table
$\pi_{fn}$ of the amount of nutrient $n$ in food $f$. Now $\Pi_n$
defines how much intake of each nutriment is needed. And $\Delta_f$
describes the maximum number of servings of each food. 

Now given prices $c_f$ for each food, we have to find a selection of foods
that obeys the restrictions and has minimal cost. 
\begin{eqnarray}
\min_{f\in F, n\in N} c_{fn} x_{fn}&&\mbox{subject to}\\
\sum_{f\in F} \pi_f x_{fn} &\ge&\Pi_n\quad\forall n\in N\\
0\leq x_{fn}&\leq&\Delta_f\quad\forall f\in F, n\in N\\
x_{fn}&\in&\N\label{eqn:integrality}
\end{eqnarray}

As (\ref{eqn:integrality}) implies, only complete servings can be
obtained. Half an egg is not an option.
Now translating this to \zimpl looks as follows:
{\small
\begin{verbatim}
set Food := {"Oatmeal","Chicken","Eggs","Milk","Pie","Pork"};
set Nutrients := { "Energy", "Protein", "Calcium" };
set Attr      := Nutrients + { "Servings", "Price" };

param needed[Nutrients] := 
  <"Energy"> 2000, <"Protein"> 55, <"Calcium"> 800;

param data[Food * Attr] := 
          |"Servings","Energy","Protein","Calcium","Price"|
|"Oatmeal"|        4 ,    110 ,       4 ,       2 ,     3 |
|"Chicken"|        3 ,    205 ,      32 ,      12 ,    24 |
|"Eggs"   |        2 ,    160 ,      13 ,      54 ,    13 |
|"Milk"   |        8 ,    160 ,       8 ,     284 ,     9 |
|"Pie"    |        2 ,    420 ,       4 ,      22 ,    20 |
|"Pork"   |        2 ,    260 ,      14 ,      80 ,    19 |;
#                       (kcal)       (g)      (mg) (cents)       
var x[<f> in Food] integer >= 0 <= data[f, "Servings"];

minimize cost: sum <f> in Food : data[f, "Price"] * x[f];

subto need :
  forall <n> in Nutrients do
    sum <f> in Food : data[f, n] * x[f] >= needed[n];
\end{verbatim}
}
\clearpage
\subsection{TSP}
In this example we show how to generate an exponential 
description of the \emph{Traveling Salesmen Problem} 
as given for example in 
\cite[Section 58.5]{Schrijver2003}.
The data is read in from a file that gives the number of the city and the
x and y coordinate. Distances between cities are geometric.
A suitable data file would look like this:
{\small
\begin{verbatim}
#City        x y 
"Sylt"       1 1
"Flensburg"  3 1
"Neumünster" 2 2
"Husum"      1 3
"Schleswig"  3 3
"Ausacker"   2 4
\end{verbatim}
}
The formulation in \zimpl follows below. Please note that \code{P[]}
holds all subsets of the cities. So don't try to solve a 52
city TSP this way. It won't work.
{\small
\begin{verbatim}
set V   := { read "tsp.dat" as "<1s>" comment "#" };
set E   := { <i,j> in V * V with i < j };
set P[] := powerset(V);
set K   := indexset(P);

param px[V] := read "tsp.dat" as "<1s> 2n" comment "#";
param py[V] := read "tsp.dat" as "<1s> 3n" comment "#";

defnumb dist(a,b) := sqrt((px[a]-px[b])^2 + (py[a]-py[b])^2);

var x[E] binary;

minimize cost: sum <i,j> in E : dist(i,j) * x[i, j];

subto two_connected:
   forall <v> in V do
      (sum <v,j> in E : x[v,j]) 
    + (sum <i,v> in E : x[i,v]) == 2;

subto no_subtour:
   forall <k> in K with 
      card(P[k]) > 2 and card(P[k]) < card(V) - 2 do
      sum <i,j> in E with <i> in P[k] and <j> in P[k] : x[i,j] 
      <= card(P[k]) - 1;
\end{verbatim}
}
\clearpage
\subsection{Capacitated Facility Location Problem}
Here we have a formulation for the \emph{Capacitated Facility
Location} Problem. Of course this is also kind of a \emph{bin packing} problem
with packing costs and variable sized bins, or a \emph{cutting stock} problem
with cutting costs.

Given a set of possible plants $P$ to built, and a set of stores $S$
with a certain demand $\delta_s$ that has to be satisfied, we have
to decide which plant should serve which store.
We have costs $c_p$ for building plant $p$ and $c_{ps}$
for transporting the goods from plant $p$ to store $s$.
Each plant has only a limited capacity $\kappa_p$.
And we insist that each store is served by exactly one plant.
Of course we are looking for the cheapest solution:

\begin{eqnarray}
\min_{p\in P, s\in S} c_p + c_{ps}&&\mbox{subject to}\\ 
\sum_{p\in P} x_{ps}& =& 1\quad\forall s\in S\label{eqn:assign}\\
x_{ps}&\leq&z_{s}\quad\forall s\in S, p\in P\label{eqn:open}\\
\sum_{s\in S} \delta_s x_{ps}&\leq&\kappa_p\quad\forall p\in P\label{eqn:capacity}\\
x_{ps},z_p&\in&\BB
\end{eqnarray}

We have binary variables $z_p$, which are set to one, iff plant $p$ is
to be build. And we have binary variables $x_{ps}$, 
which are set to one iff plant $p$ serves shop $s$. 
Equation (\ref{eqn:assign}) demands that each store is assigned to
exactly one plant. Equation (\ref{eqn:open}) makes sure that a plant
that serves a shop is built. And Equation (\ref{eqn:capacity})
restricts the shops that are served by a plant to the plants capacity.
Putting this into \zimpl yields:
{\small
\begin{verbatim}
set PLANTS := { "A", "B", "C", "D" };
set STORES := { 1 .. 9 };
set PS     := PLANTS * STORES;

# How much does it cost to build a plant and what capacity 
# will it then have?
param building[PLANTS]:= <"A">500,<"B">600,<"C">700,<"D">800;
param capacity[PLANTS]:= <"A"> 40,<"B"> 55,<"C"> 73,<"D"> 90;

# Here is the demand of each store
param demand  [STORES]:= <1> 10,<2> 14,<3> 17,<4> 8,<5> 9,
                         <6> 12,<7> 11,<8> 15,<9> 16;

# Transportation cost from each plant to each store
param transport[PS] := 
      |  1,  2,  3,  4,  5,  6,  7,  8,  9 |
  |"A"| 55,  4, 17, 33, 47, 98, 19, 10,  6 |
  |"B"| 42, 12,  4, 23, 16, 78, 47,  9, 82 | 
  |"C"| 17, 34, 65, 25,  7, 67, 45, 13, 54 |
  |"D"| 60,  8, 79, 24, 28, 19, 62, 18, 45 |;

var x[PS]     binary;  # Is plant p suppling store s ?
var z[PLANTS] binary;  # Is plant p build ?

# We want it cheap
minimize cost: sum <p> in PLANTS : building[p] * z[p]
             + sum <p,s> in PS : transport[p,s] * x[p,s];

# Each store is supplied by exactly one plant
subto assign: 
  forall <s> in STORES : sum <p> in PLANTS : x[p,s] == 1;
   
# To be able to supply a store, a plant must be build
subto build: forall <p,s> in PS : x[p,s] <= z[p];

# The plant must be able to meet the demands from all stores
# that are connected to it
subto limit: forall <p> in PLANTS :
   sum <s> in S : demand[s] * x[p,s] <= capacity[p];
\end{verbatim}
}

The optimal solution in this case is to build plants \code{A} and
\code{C}. Stores 2, 3, and 4 are served by plant \code{A}, the rest by
plant \code{C}. Total cost would be 1457.

\clearpage
\subsection{$n$-Queens Problem}
\label{ssec:example:n-queens-problem}
We now show two formulations of the $n$-Queens problems using 
extended constraints and functions. 

The first formulation uses 
one general integer variable for each row of the board.
Each variable can take the value of a column. So we have $n$ variables 
with bounds $1\ldots n$. Next we use the 
\code{vabs} extended function to model an \emph{all different}
constraint on the variables (see constraint c1). 
This makes sure that no queen is located
on the same column than any other queen.
The second constraint (c2) is used to block all the diagonals of a
queen. This is done by demanding that the absolute row and the column 
distance of each pair of queens is different. We model $a\neq b$ by
$\mbox{abs}(a-b)\geq 1$.

Note that this formulation only works if a queen can be placed in each
row,\ie the board size has to be at least $4\times4$.

{\small
\begin{verbatim}
param queens := 8;

set I := { 1 .. queens };
set P := { <i,j> in I * I with i < j };
 
var x[I] integer >= 1 <= queens;

subto c1: forall <i,j> in P do vabs(x[i] - x[j]) >= 1;
subto c2: forall <i,j> in P do 
   vabs(vabs(x[i] - x[j]) - abs(i - j)) >= 1;
\end{verbatim}
}

Here we do the same with one binary variable for each field of the
board. The variable is one iff a queen is on this field.
We compute in advance which other fields are blocked if a queen is
placed on a particular field. Then we use the extended \code{vif}
constraint to set the variables of the blocked fields to zero if a
queens is placed. %We maximize the number of queens allowed.

{\small
\begin{verbatim}
param columns := 8;

set I   := { 1 .. columns };
set IxI := I * I;

set TABU[<i,j> in IxI] := { <m,n> in IxI with 
   (m != i or n != j) and 
   (m == i or n == j or abs(m - i) == abs(n - j)) };

var x[IxI] binary;

maximize queens: sum <i,j> in IxI : x[i,j];

subto c1: forall <i,j> in IxI do
   vif x[i,j] == 1 then 
      sum <m,n> in TABU[i,j] : x[m,n] <= 0 end;
\end{verbatim}
}


